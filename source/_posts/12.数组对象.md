---
title: 数组对象
date: 2019-10-8 23:37:18
tags:
---
## Array 对象
上一篇我们说的是数组的基础知识，这一次我们来看看数组对象。
### 构造函数
`Array`是一个构造函数，可以用它生成新的数组。
```js
var arr = new Array(2);
arr.length // 2
arr // [ empty x 2 ] 生成两个空值
```
如果没有使用`new`关键字，运行结果也是一样的。
上面的参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回`undefined`，但实际上该位置没有任何值。虽然可以取到`length`属性，但是取不到键名。
```js
arr[0]  //undefined
arr[1]  //undefined
```

`Array`构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。
```js
var a = new Array(3)  //[ empty x 3 ]

var b = new Array(2,3) //[2, 3]  
```
一个参数生成的是长度，二个参数生成的则是数组成员，所以我们推荐使用下面这种方法声明数组。
直接使用数组字面量是更好的做法。
```js
var a = [2, 3]
```
### 实例方法
**valueOf()，toString()**
`valueOf`方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的`valueOf`方法不尽一致，数组的`valueOf`方法返回数组本身。
```js
var arr = [1, 2, 3];
arr.valueOf() // [1, 2, 3]
```
`toString`方法也是对象的通用方法，数组的`toString`方法返回数组的字符串形式。
```js
var arr = [1, 2, 3];
arr.toString() // "1,2,3"

var arr = [1, 2, 3, [4, 5, 6]];
arr.toString() // "1,2,3,4,5,6"
```
**push()，pop()**
`push`方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。
```js
var arr = [];

arr.push(1) // 1
arr.push('a') // 2
arr.push(true, {}) // 4
arr // [1, 'a', true, {}]
```
上面代码使用`push`方法，往数组中添加了四个成员。
`pop`方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。
```js
var arr = ['a', 'b', 'c'];

arr.pop() // 'c'
arr // ['a', 'b']
```
对空数组使用`pop`方法，不会报错，而是返回`undefined`。
```js
[].pop() // undefined
```
`push`和`pop`结合使用，就构成了“先进后出”的栈结构（stack）。

**shift()，unshift()**

`shift()`方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。
```js
var a = ['a', 'b', 'c'];

a.shift() // 'a'
a // ['b', 'c']
```
上面代码中，使用`shift()`方法以后，原数组就变了。
`unshift()`方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。
```js
var a = ['a', 'b', 'c'];

a.unshift('x'); // 4
a // ['x', 'a', 'b', 'c']
```
`unshift()`方法可以接受多个参数，这些参数都会添加到目标数组头部。
```js
var arr = [ 'c', 'd' ];
arr.unshift('a', 'b') // 4
arr // [ 'a', 'b', 'c', 'd' ]
```

`push()`和`shift()`结合使用，就构成了“先进先出”的队列结构（queue）。

**sort()**
sort方法对数组成员进行排序,排序后，原数组将被改变。
```js
['d', 'c', 'b', 'a'].sort()
// ['a', 'b', 'c', 'd']

[4, 3, 2, 1].sort()
// [1, 2, 3, 4]

[11, 101].sort()
// [101, 11]

[10111, 1101, 111].sort()
// [10111, 1101, 111]
```
上面代码的最后两个例子，需要特殊注意。`sort()`方法不是按照大小排序，而是按照字典顺序。
如果想让`sort`方法按照自定义方式排序，可以传入一个函数作为参数。
```js
[10111, 1101, 111].sort(function (a, b) {
  return a - b;
})
// [111, 1101, 10111]
```