---
title: 数组和伪数组
date: 2019-09-15 22:47:57
tags:
---
## 数组
### 什么是数组？
数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。
```js
var arr = ['a', 'b', 'c'];
//也可以像下面这样先定义后赋值。
var arr = [];

arr[0] = 'a';
arr[1] = 'b';
arr[2] = 'c';
```
上面代码中的`a`、`b`、`c`就构成一个数组，两端的方括号是数组的标志。`a`是0号位置，`b`是1号位置，`c`是2号位置。
任何类型的数据，都可以放入数组。
```js
var arr = [
  {a: 1},
  [1, 2, 3],
  function() {return true;}
];

arr[0] // Object {a: 1}
arr[1] // [1, 2, 3]
arr[2] // function (){return true;}
```
上面数组arr的3个成员依次是对象、数组、函数。

### 数组的本质
本质上，数组属于一种特殊的对象。`typeof`运算符会返回数组的类型是`object`。
```js
typeof [1, 2, 3] // "object"
```
数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2...）。
```js
var arr = ['a', 'b', 'c'];

Object.keys(arr)
// ["0", "1", "2"]
```
上面代码中，`Object.keys`方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。(其实是字符串)之所以可以用数值读取，是因为非字符串的键名会被转为字符串。
由于数组成员的键名是固定的（默认总是0、1、2...），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。
数组成员只能用方括号`arr[0]`表示（方括号是运算符，可以接受数值）。
### length 属性
只要是数组，就一定有`length`属性。该属性是一个动态的值，等于键名中的最大整数加上1。
```js
var arr = ['a', 'b'];
arr.length // 2

arr[2] = 'c';
arr.length // 3

arr[9] = 'd';
arr.length // 10

arr[1000] = 'e';
arr.length // 1001
```
数组是一种动态的数据结构，可以随时增减数组的成员。
`length`属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到`length`设置的值。在数组中多出来的成员，会被自动删除了。
清空数组的一个有效方法，就是将`length`属性设为0。
```js
var arr = [ 'a', 'b', 'c' ];

arr.length = 0;
arr // []
```
如果人为设置`length`大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。读取新增的位置都会返回`undefined`。
### 遍历数组
数组的遍历可以考虑使用`for`循环或`while`循环。
```js
var a = [1,2,3]
//for循环
for(var i=0; i<a.length; i++){
  console.log(a[i])
}

//while 循环
var i = 0
while(i<a.length){
  console.log(a[i])
  i++
}
```
数组的`forEach`方法，也可以用来遍历数组
`forEach`方法接收一个函数作为参数。该函数调用时，`forEach`向它传入三个参数：数组成员、索引、数组本身。
```js
var colors = ['red', 'blue', 'green']
colors.forEach(function(ele, index, array){
  console.log(index + ' = ' + ele)
})
//0 = red
//1 = blue
//2 = green
```
### 数组的空位
当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。如果最后一个元素后面有逗号，并不会产生空位。
数组的空位不影响`length`属性。
数组的空位是可以读取的，返回`undefined`。
```js
var a = [, , ,];
a[1] // undefined
```
使用`delete`命令删除一个数组成员，会形成空位。length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心。
数组的某个位置是空位，与某个位置是`undefined`，是不一样的。如果是空位，使用数组的`forEach`方法、`for...in`结构、以及`Object.keys`方法进行遍历，空位都会被跳过。
```js
var a = [, , ,];

a.forEach(function (x, i) {
  console.log(i + '. ' + x);
})
// 不产生任何输出

for (var i in a) {
  console.log(i);
}
// 不产生任何输出

Object.keys(a)
// []
```
如果某个位置是`undefined`，遍历的时候就不会被跳过。
```js
var a = [undefined, undefined, undefined];

a.forEach(function (x, i) {
  console.log(i + '. ' + x);
});
// 0. undefined
// 1. undefined
// 2. undefined

for (var i in a) {
  console.log(i);
}
// 0
// 1
// 2

Object.keys(a)
// ['0', '1', '2']
```
空位就是数组没有这个元素，所以不会被遍历到，而`undefined`则表示数组有这个元素，值是`undefined`，所以遍历不会跳过。

## 伪数组
### 类似数组的对象特征
1. 对象的所有键名都是正整数或零，并且有`length`属性这些`key`。
2. 原型链中没有`Array.prototype`就是。如：`Arguments`

```js
var obj = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3
};

obj[0] // 'a'
obj[1] // 'b'
obj.length // 3
obj.push('d') // TypeError: obj.push is not a function
```
对象`obj`就是一个类似数组的对象。但是，它并不是数组，因为它不具备数组特有的方法。对象`obj`没有数组的`push`方法，使用该方法就会报错。

只要有`length`属性，就可以认为这个对象类似于数组。但是有一个问题，这种`length`属性不是动态值，不会随着成员的变化而变化。
```js
var obj = {
  length:0
}
obj[1] = 'a'
obj.length //0
```
上面代码为对象`obj`添加了一个数字键，但是`length`属性没变。这就说明了`obj`不是数组。
我们可以用`instanceof`方法来鉴定一个对象是否是数组。
```js
//arguments
function args(){
  return arguments
}
var arrayLike = args('a', 'b')
arrayLike[0]  // 'a'
arrayLike.length  // 2
arrayLike instanceof Array // false

// DOM元素集
var elts = document.getElementsByTagName('h3');
elts.length // 3
elts instanceof Array // false

// 字符串
'abc'[1] // 'b'
'abc'.length // 3
'abc' instanceof Array // false
```
以上三个例子都不是数组。
### 把伪数组变成真正的数组
数组的`slice`方法可以将“类似数组的对象”变成真正的数组。
```js
var arr = Array.prototype.slice.call(arrayLike)
```
除了转为真正的数组，还有一个办法可以使用数组的方法，就是通过`call()`把数组的方法放到对象上面。
```js
function print(value, index) {
  console.log(index + ' : ' + value);
}

Array.prototype.forEach.call(arrayLike, print);
```
上面代码中，`arrayLike`代表一个类似数组的对象，本来是不可以使用数组的`forEach()`方法的，但是通过`call()`，可以把`forEach()`嫁接到`arrayLike`上面调用。

这种方法比直接使用数组原生的`forEach`要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的`forEach`方法。
```js
var arr = Array.prototype.slice.call('abc');
arr.forEach(function (chr) {
  console.log(chr);
});
// a
// b
// c
```
