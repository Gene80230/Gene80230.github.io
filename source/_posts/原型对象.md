---
title: 全局对象和原型对象
date: 2019-09-03 23:36:32
tags:
---
## 全局对象 window
`ECMAScript` 规定全局对象叫做 `global`，但是浏览器默认把`window` 作为全局对象，毕竟是浏览器先存在的，于是就沿用至今。
`window` 就是一个哈希表，有很多属性。
`window` 的属性就是全局变量，这些全局变量分为两种：
1. 一种是 ECMAScript 规定的
    - global.parseInt
    - global.parseFloat
    - global.Number
    - global.String
    - global.Boolean
    - global.Object

2. 一种是浏览器私有的
    - window.alert
    - window.prompt
    - window.comfirm
    - window.console.log
    - window.console.dir
    - window.document
    - window.document.createElement
    - window.document.getElementById

我们暂时只学习全局对象`Window`。

## 公用属性(`.__proto__`)
[上一节](https://gene80230.github.io/2019/08/29/%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%86%85%E5%AD%98%E5%9B%BE%E8%A7%A3/)笔记我们讲到一个概念叫包装对象，大家也都明白了基本类型值的存储方式和对象的存储方式是不同的。基本类型是存储在栈(`stack`)中。而对象在声明的时候，地址存储在栈(`stack`)中，地址中的内容则是存储在堆(`Heap`)中。

这里介绍两种它们共同具有、从Object对象继承的方法：`valueOf()`和`toString()`。
**valueOf()**

`valueOf()`方法返回包装对象实例对应的原始类型的值。
```js
new Number(123).valueOf()  // 123
new String('abc').valueOf() // "abc"
new Boolean(true).valueOf() // true
```
**toString()**

`toString()`方法返回对应的字符串形式。
```js
new Number(123).toString() // "123"
new String('abc').toString() // "abc"
new Boolean(true).toString() // "true"
```
所有对象都有`valueOf()`和`toString()`方法，那么我们是否有必要给每个对象一个`toString`和 `valueOf` 方法呢？明显不需要。
`JavaScript`的做法是把`toString`和`valueOf`放在一个对象里（暂且叫做公用属性组成的对象）然后让每一个对象的 __proto__ 指向这个「公用属性组成的对象」的地址。
这样，既可以节省内存，又不用频繁的去创造很多不必要的对象。

一般js有两种情况可以调用原型对象。
- 原始类型与实例对象的自动转换
- 调用对象

### 原始类型与实例对象的自动转换
我们先来声明一个字符串
```js
var n1 = 'abc'
n1.length   //3
```
某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。

比如，字符串可以调用`length`属性，返回字符串的长度。

上面代码中，`n1`是一个字符串，本身不是对象，不能调用`length`属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用`length`属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。

自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。如果硬添加上去会返回`undefined`。

另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象`String.prototype`上定义。

### 调用对象
还有一种情况是你声明的变量已经是一个对象了，但你调用`toString`函数并不是自身就拥有的，而是继承自`__proto__` ， 因为这样你才能调用`toString`函数。
![18:31:51](https://i.loli.net/2019/09/12/9D2xw1o3mCqzPJT.png)
基本类型的构造函数已经自定义了对应自身的toString方法，这个方法跟对象的toString方法是不一样的
具体引用关系如下图：
![18:32:40](https://i.loli.net/2019/09/12/7PzmCDRLM6QrI1S.png)
![18:33:00](https://i.loli.net/2019/09/12/E4SClXZFfxcRLhA.png)
当我们不写代码的时候，内存中有全局对象Window，对象中有Number、Object、String、Boolean 这几个函数
![18:34:37](https://i.loli.net/2019/09/12/dpJbuWnhQo4aekI.png)
当你写代码的时候
![18:34:33](https://i.loli.net/2019/09/12/8dEnWMaXhNY4zT9.png)
### 各个`.__proto__`与`.prototype`的关系：
基本类型的构造函数遵循这样的规则：对象.__proto__ 指向构造函数.prototype
```js
var n = new Number(2)
n.__proto__ === Number.prototype
//true
```
又因为`Number.prototype`作为一个对象，它指向了`Object.prototype`
```js
Number.prototype.__proto__ === Object.prototype
//true
//根据上面这条我们可以推出下面这条
n.__proto__.__proto__ === Object.prototype
//true
```
接下来是`Object`
```js
var object = new Object()
object.__proto__ === Object.prototype
//true
```
而`Object`作为一个函数，它是`Function`构造出来的，它的`.__proto__`指向了`Function.prototype`。
另外需要说明下，所有的函数都是`Function`构造出来的，它们也都一样指向了`Function.prototype`。
```js
Object.__proto__ === Function.prototype
//true
Number.__proto__ === Function.prototype
//true  其他构造函数是一样的指向
```
但`Function`因为自身是实例，也是构造函数，它的原型对象就是自身。
```js
Function.__proto__ === Function.prototype
//true
```
比较特殊的是，`Object.prototype`自身作为对象也是有`.__proto__`的，但是它却指向了`null`
```js
Object.prototype.__proto__ === null
```
所以我们今天的知识总结称为一句话，大概就是：
**对象.__proto__ === 构造函数.prototype**
