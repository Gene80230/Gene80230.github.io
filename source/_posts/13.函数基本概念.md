---
title: 函数
date: 2019-10-15 18:33:37
tags:
---
## 基本概念
函数是一段可以反复调用的代码块。
### 函数的声明
**（1）function命令**
```js
function print(s){ 
    //函数体
    console.log(1)
}

print() //函数调用
```
`function`命令声明的代码区块，就是一个函数。`function`命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。

**（2）函数表达式/匿名函数**
除了可以用上面的方式声明函数，我们还可以使用变量赋值的写法。
```js
var print = function(s) {
  console.log(s);
};
```
这种写法将一个匿名函数赋值给变量。这个匿名函数又称函数表达式（Function Expression）

采用函数表达式声明函数时，`function`命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。

**（3）Function 构造函数**

第三种声明函数的方式是`Function`构造函数。
```js
var add = new Function(
  'x',
  'y',
  'return x + y'
);

// 等同于
function add(x, y) {
  return x + y;
}
```
上面代码中，`Function`构造函数接受三个参数，除了最后一个参数是`add`函数的“函数体”，其他参数都是`add`函数的参数。如果有多个参数，那最后一个参数会被当做函数体。如果只有一个参数，该参数就是函数体。
```js
var foo = new Function(){
    'return "Hello World";'
};

//等同于
function foo(){
    return 'Hello World';
}
```
### 函数的重复声明
如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。
```js
function f() {
  console.log(1);
}
f() // 2

function f() {
  console.log(2);
}
f() // 2
```
上面代码中，后一次的函数声明覆盖了前面一次。

### 函数的调用
调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。
```js
function add(x, y) {
  return x + y;
}

add(1, 1) // 2  函数名后面紧跟一对圆括号，就会调用这个函数。
```
函数体内部的`return`语句，表示返回。JavaScript会直接返回`return`后面的那个表达式的值，后面即使还有语句，也不会得到执行。
`return`语句所带的那个表达式，就是函数的返回值。`return`语句不是必需的，如果没有的话，默认返回`undefined`。

### 函数与其他数据类型的关系
凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。
```js
function add(x, y){
    return x + y
}
//将函数赋值给一个变量
var operator = add

//将函数作为参数和返回值
function a(op){
    return op
}

a(add)(1, 1)
//2
```
### 函数名的提升

JavaScript 引擎将函数名视同变量名，所以采用`function`命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。
```js
f();

function f() {}
```
但是，如果采用赋值语句定义函数，就会报错。
```js
f();
var f = function (){};
// TypeError: undefined is not a function

//上面的代码等同于下面的形式。
var f;
f();
f = function () {};
```
如果同时采用`function`命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。
```js
var f = function () {
  console.log('1');
}

function f() {
  console.log('2');
}

f() // 1
```
## 函数的属性和方法
函数的`toString`方法返回一个字符串，内容是函数的源码。
```js
function f(){
	console.log(1)
}

f.toString()
// "function f(){
// 	console.log(1)
// }"
```
对于那些原生的函数，`toString()`方法返回`function (){[native code]}`。
```js
Math.sqrt.toString()
// "function sqrt() { [native code] }"
```
上面代码中，`Math.sqrt`是 JavaScript 引擎提供的原生函数，`toString()`方法就返回原生代码的提示。
函数内部的注释也可以返回。
```js
function f(){
/*这是一个
多行字符串
*/}
f.toString()
//"function f(){
///*这是一个
//多行字符串
//*/}"
```
利用这一点，可以变相实现多行字符串。
```js
function multiline(fn){
  var arr = fn.toString().split('/n')
  return arr.slice(1, arr.length-1).join('/n')
}

function f(){/*
  这是一个
多行字符串
*/}

multiline(f)
//"这是一个
// 多行字符串"
```

## 函数作用域
### 基本概念
作用域（scope）指的是变量存在的范围。目前（ES5），JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。
对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。
```js
var v = 1
function f(){
  console.log(v)
}

f()
//  1
```
上面代码中，函数`f`内部可以读取全局变量`v`。

在函数内部定义的变量，外部无法读取，称为"局部变量"。
```js
function f(){
  var v = 1
}

v 
// ReferenceError: v is not defined
```
### 函数内部的变量提升
与全局作用域一样，函数作用域内部也会产生“变量提升”现象。`var`命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。
```js
function foo(x){
  if(x > 100){
    var tmp = x - 100
  }
}

//等同于
function foo(x){
  var tmp
  if(x > 100){
    tmp = x - 100
  }
}
```
### 函数本身的作用域
函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。
```js
var a = 1
var x = function (){
  console.log(a)
}

function f(){
  var a = 2
  x()
}
f()
//  1
```
上面代码中，函数`x`是在函数f的外部声明的，所以它的作用域绑定外层，内部变量`a`不会到函数`f`体内取值，所以输出`1`，而不是`2`。

总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。

很容易犯错的一点是，如果函数`A`调用函数`B`，却没考虑到函数`B`不会引用函数`A`的内部变量。
```js
var x = function () {
  console.log(a);
};

function y(f) {
  var a = 2;
  f();
}

y(x)
// ReferenceError: a is not defined
```
上面代码将函数`x`作为参数，传入函数`y`。但是，函数x是在函数`y`体外声明的，作用域绑定外层，因此找不到函数`y`的内部变量`a`，导致报错。
## 参数
### 基本概念
函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。
```js
function square(x) {
  return x * x;
}

square(2) // 4
square(3) // 9
```
上式的`x`就是`square`函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。
### 参数的省略
函数参数不是必需的，JavaScript 允许省略参数。
```js
function f(a, b) {
  return a;
}

f(1, 2, 3) // 1
f(1) // 1
f() // undefined

f.length // 2
```
上面代码的函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为`undefined`。需要注意的是，函数的`length`属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。

但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入`undefined`。

但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入`undefined`。

### 传递方式
函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。
```js
var p = 2;

function f(p) {
  p = 3;
}
f(p);

p // 2
```
上面代码中，变量p是一个原始类型的值，传入函数f的方式是传值传递。因此，在函数内部，p的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。

但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。
```js
var obj = { p: 1 };

function f(o) {
  o.p = 2;
}
f(obj);

obj.p // 2
```
上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。

注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。
```js
var obj = [1, 2, 3];

function f(o) {
  o = [2, 3, 4];
}
f(obj);

obj // [1, 2, 3]
```
上面代码中，在函数`f`内部，参数对象`obj`被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（`o`）的值实际是参数`obj`的地址，重新对`o`赋值导致`o`指向另一个地址，保存在原地址上的值当然不受影响。

