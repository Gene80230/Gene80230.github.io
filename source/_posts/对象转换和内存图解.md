---
title: 对象转换和内存图解
date: 2019-08-29 23:12:32
tags:
---
## 内存图解与Object类型转换
对象跟基本类型的存储方式是有所差异的，这里我们要说下内存。
### 内存图解
当我们开机的时候，电脑会把系统从硬盘里面读取到内存中，这里操作系统要占用若干内存，一般是512M，具体要看系统大小。
开机之后，我们使用浏览器，大概会占用1G内存，这1G里面有分给每个网页100M，网页里面又有HTML+CSS、JS、网络 HTTP、其他（插件、定时器）来占用这100M
![Markdown](http://i2.tiimg.com/644982/04a09b2422ceac00.png '内存分配图')

当我们在js里面声明一个变量等于1时，内存会进行分区，分为代码区和数据区。代码区用来存代码。数据区是用来放你声明了一个数字，字符串，对象的地方，但是数据区又分为堆(heap)和栈(stack)
![Markdown](http://i2.tiimg.com/644982/8eba28bcf46160be.png '内存分区')
注意：
当你声明了一个变量，浏览器首先做的是变量提升，如果它是数字，它就会以64位浮点数的方式存储在栈中。当我们有两个变量，分别是a(1)和b(2)，我们把a赋给b，在栈中，是直接把a所在的栈，覆盖掉b所在栈的。
![Markdown](http://i2.tiimg.com/644982/08aa51a638227366.png)

接着我们来存对象，js在存储数据时，每个字符是16位，而一个栈每一行能存64位，也就是说一行能存4个字符.
![Markdown](http://i2.tiimg.com/644982/aadcdd3e90df69f4.png)
对象的赋值是按照堆所对应的地址来存储的，如果要让一个对象赋值给另一个对象，这种情况是直接改变被对象在栈中的地址，然后指向它。后续的添加值则是在对象指向的堆中添加。
![Markdown](http://i2.tiimg.com/644982/128ce7d846446452.png)

### 引用
上面说了对象的赋值是按照堆所对应的地址来存储的，这种关系就叫引用。
如`object`存了`{'name':'Gene'}`对象，那我们就说object是对象的引用。

### 各个类型转Object（包装对象）
>所谓“包装对象”，指的是与数值、字符串、布尔值分别相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。
```js
var v1 = new Number(123);
var v2 = new String('abc');
var v3 = new Boolean(true);

typeof v1 // "object"
typeof v2 // "object"
typeof v3 // "object"

v1 === 123 // false
v2 === 'abc' // false
v3 === true // false
```
上面是摘抄自阮一峰老师[包装对象](https://wangdoc.com/javascript/stdlib/wrapper.html)这一章节。
```js
var obj = Object();
// 等同于
var obj = Object(undefined);
var obj = Object(null);

obj instanceof Object // true
//上面代码的含义，是将undefined和null转为对象，结果得到了一个空对象obj。
```
`instanceof`运算符用来验证，一个对象是否为指定的构造函数的实例。`obj instanceof Object`返回`true`，就表示`obj`对象是`Object`的实例。

上面第一段代码中，基于原始类型的值，生成了三个对应的包装对象。可以看到，v1、v2、v3都是对象，且与对应的简单类型值不相等。

上面说到`Number`、`String`和`Boolean`这三个原生对象，如果不作为构造函数调用（即调用时不加new），而是作为普通函数调用，常常用于将任意类型的值转为数值、字符串和布尔值。

总结一下，这三个对象作为构造函数使用（带有`new`）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有`new`），可以将任意类型的值，转为原始类型的值。

### 面试题
左上角为问题，图解是答案。
![Markdown](http://i2.tiimg.com/644982/aeaea69ca3cced62.png)
上面最终答案`a = 1`

![Markdown](http://i2.tiimg.com/644982/09cf593170efe884.png)
上面最终答案`a = {name: "Gene"}`

![Markdown](http://i2.tiimg.com/644982/fc50ceb13088df19.png)
上面最终答案`a.name = "b"`

![Markdown](http://i2.tiimg.com/644982/2379dc73254a1124.png)
上面最终答案`a= {name: "a"}`

![Markdown](http://i2.tiimg.com/644982/ebb0cb5679bb6204.png)
答案在上面已经给出，至于为什么这样，我们来分析下。
首先按照上面的步骤，浏览器是从左往右读取的，到第三句，这时候`a`还是34的地址，浏览器在这里确定了`a`的值为ADDR34所对应的数据，之后再往右边读取，把新的对象赋给`a`，但是`a`之前已经确定下来了，还是原来的地址，所以最后问`a.x`，答案是`a.x`不存在。`b.x`因为浏览器调用了`toString`方法，所以打出`object Object`

### 垃圾回收
概念：一个页面用完的内存，还给浏览器，浏览器再给别的页面使用。
**什么情况下回出现垃圾回收**
>如果一个对象没有被引用，它就是垃圾，将会被回收。

下面是一个垃圾回收的简单例子
![Markdown](http://i2.tiimg.com/644982/64ffa4db8fabbc66.png)

垃圾回收经典面试题
![Markdown](http://i2.tiimg.com/644982/fab11e71e10d0a5b.png)

### 浅拷贝和深拷贝
**浅拷贝**
![Markdown](http://i2.tiimg.com/644982/2379dc73254a1124.png)
上面`b`变至`a`变，我们称为浅拷贝